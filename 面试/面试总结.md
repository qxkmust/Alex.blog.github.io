- 什么是IOC

  ```
  控制反转，又被称为依赖注入(DI)，是一种通过反射机制降低对象之间耦合关系的设计思想。Spring采用IOC的方式把实例化的对象注入到自定义的对象中。
  Demo实现：
  1、配置Spring Config的xml文件，定义<bean>（每个bean都有对应的类），属性<property>可初始化实例：
      <bean id="tea" class="spring.bean.Tea" scope="singleton">
          <property name="name" value="红茶"/>
          <property name="price" value="22.0"/>
      </bean>
  2、使用FileSystemXmlApplicationContext（绝对路径读取xml）
  或者ClassPathXmlApplicationContext（classpath相对路径读取xml），将实例化后的对象注入到spring容器中(scope默认是singleton，只会生成Tea的唯一bean，而scope=prototype时，可以生成过个bean，类似于new)。
  ```

  ![1576905056736](https://github.com/qxkmust/Alex.blog.github.io/blob/blog/Images/1576905056736.png?raw=true)

- 什么是AOP

  ```
  面向切面编程(AOP)是对面向对象开发(OOP)的一种补充，它允许在不改变原来模型的基础上动态的修改模型以满足新的需求（可以动态扩展），常用来动态增加日志、异常处理、鉴权。
  AOP常见的实现方式JDK静态代理、JDK动态代理、Cglib第三方代理
  ```

  - JDK静态代理

     若代理类在程序运行前就已经存在，那么这种代理方式被称为静态代理，原理是与目标类实现相同的接口，在代理类中切入增强逻辑。

    ```
    public class Jdk静态代理 implements Deal {
        private Deal target = new Consumer();
        @Override
        public void buy() {
            System.out.println("Before invoke buy()");
            target.buy();
            System.out.println("After invoke buy()");
        }
    }
    ```

    调用

    ```
    public void test01(){
    	Jdk静态代理 proxy = new Jdk静态代理();
    	proxy.buy();
    }
    ```

  - JDK动态代理

    大概流程

    1、为接口创建代理类的字节码文件
  
    2、使用ClassLoader将字节码文件加载到JVM
  
    3、创建代理类实例对象，执行对象的目标方法
  
    ```
    public class Jdk动态代理 implements InvocationHandler {
    //    代理对象
        private Object target;
    
        public Jdk动态代理(Object target) {
            this.target = target;
        }
    
        public Object getTargetProxy(){
            return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
        }
    
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println("Before invoke "+method.getName());
          Object invoke = method.invoke(target, args);
            System.out.println("After invoke "+method.getName());
          return invoke;
        }
    }
    ```
  
    调用
  
    ```
     public void test02(){
            Consumer target = new Consumer();
          target.setProduct(new Tea("大红袍",99.0f));
            Jdk动态代理 jdk = new Jdk动态代理(target);
          Deal proxy = (Deal) jdk.getTargetProxy();
            proxy.buy();
      }
    ```
  
  - Cglib
  
    实现MethodInterceptor
  
    ```
    public class Cglib implements MethodInterceptor {
        /**
         * 重写方法拦截，在方法前和方法后增加业务
         * @param target 目标对象
         * @param method 目标方法
         * @param args 参数
         * @param methodProxy 方法代理对象
         * @return
         * @throws Throwable
         */
        @Override
        public Object intercept(Object target, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
            System.out.println("Before invoke "+method.getName());
          Object invokeSuper = methodProxy.invokeSuper(target, args);
            System.out.println("After invoke "+method.getName());
          return invokeSuper;
        }
    }
    ```
  ```
  
    调用-使用Enhancer字节码增强器
  
  ```
    public void test03(){
  //通过字节码增强器对目标方法进行扩展
        Enhancer enhancer = new Enhancer();
      enhancer.setSuperclass(Product.class);
        enhancer.setCallback(new Cglib());
        Product proxy = (Product) enhancer.create();
        proxy.discount();
    }
  
- 什么情况下重写equals和hashcode方法？

  ```
  因为Object类中equals方法只是比较两个对象的地址，如果要比较两个不同对象的值，就需要重写equals方法
  1、String类型已经重写了equals和hashcode方法,如下
  public int hashCode() {
          int h = hash;
          if (h == 0 && value.length > 0) {
              char val[] = value;
  
              for (int i = 0; i < value.length; i++) {
                  h = 31 * h + val[i]; //jvm在编译时会将31 * h做移位运算h << 5 - h,提高效率
              }
              hash = h;
          }
          return h;
      }
   public boolean equals(Object anObject) {
          if (this == anObject) {
              return true;
          }
          if (anObject instanceof String) {
              String anotherString = (String)anObject;
              int n = value.length;
              if (n == anotherString.value.length) {
                  char v1[] = value;
                  char v2[] = anotherString.value;//转换为字符数组
                  int i = 0;
                  while (n-- != 0) { //遍历比较字符数组
                      if (v1[i] != v2[i])
                          return false;
                      i++;
                  }
                  return true;
              }
          }
          return false;
      }
  所以字符串对象比较不需要重写equals和hashcode方法
  2、其他对象类型，分两种情况：
  	2.1、对象中的属性只有基本数据类型以及String类型（依次比较各个属性的值是否相等，String需要转换成字符数组逐个比较），不需要重写hashcode方法，因为equals中没有用到hashcode
  	@Override
      public boolean equals(Object product){
          if(this == product){
              return true; //两个对象内存地址相同，一定相同
          }
          if(product instanceof Product){
              Product obj = (Product) product;
              String name = obj.getName();
              Float price = obj.getPrice();
              int len = name.length();
              if(this.getPrice() == price && this.getName().length() == len){
              //如果基本数据类型price不等且name长度不等，对象肯定不等
                  char[] nameCharArray = name.toCharArray();
                  char[] nameCharArray_ = this.getName().toCharArray();
                  for (int i = 0; i < len; i++) {
                      if(nameCharArray[i] != nameCharArray_[i]){
                          return false;
                      }
                  }
                  return true;
              }
              return false;
          }
          return true;
      }
  	2.2、对象中的属性包括对象类型（包含另一个类中的对象），在equals方法中就要比较两个属性的hashcode值，因此需要重写hashcode方法
  3、使用Hash算法的数据结构，如HashSet（数据不重复）put方法使用equals和hashcode方法保证元素不重复，也需要对自定义的元素（比如类的实例对象）重写equals和hashcode方法
  ```

- HashMap扩容机制？

  ```
  HashMap初始容量initialCapacity默认2 << 4就是16，如果存入的数据量达到initialCapacity * loadFactor = 16 * 0.75 = 12时，会发生扩容，JDK1.7扩容的过程:
  ```

  put方法：

  ```
  public V put(K key, V value) {
          //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因
          if (key == null)
              return putForNullKey(value); // 如果当前key=null已经存在，将value存入到旧的key=null中的Entry，如果key=null不存在，直接存
          //计算key的hash值
          int hash = hash(key.hashCode());  ------(1)
          //计算key hash 值在 table 数组中的位置
          int i = indexFor(hash, table.length); ------(2)
          //从i出开始迭代 e,找到 key 保存的位置
          for (Entry<K, V> e = table[i]; e != null; e = e.next) {
              Object k;
              //判断该条链上是否有hash值相同的(key相同)
              //若存在相同，则直接覆盖value，返回旧value
              if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                  V oldValue = e.value;    //旧值 = 新值
                  e.value = value;
                  e.recordAccess(this);
                  return oldValue;     //返回旧值
              }
          }
          //修改次数增加1
          modCount++;
          //将key、value添加至i位置处
          addEntry(hash, key, value, i);
          return null;
      }
  ```

  resize和transfer方法：

  ```
  void resize(int newCapacity) {   //传入新的容量  
      Entry[] oldTable = table;    //引用扩容前的Entry数组  
      int oldCapacity = oldTable.length;  
      if (oldCapacity == MAXIMUM_CAPACITY) {  //扩容前的数组大小如果已经达到最大(2^30)了  
          threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 
          return;  
      }  
      Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组  
      transfer(newTable);                         //！！将数据转移到新的Entry数组里  
      table = newTable;                           //HashMap的table属性引用新的Entry数组  
      threshold = (int) (newCapacity * loadFactor);//修改阈值  
  }  
  其中，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里：
  void transfer(Entry[] newTable) {  
      Entry[] src = table;                   //src引用了旧的Entry数组  
      int newCapacity = newTable.length;  
      for (int j = 0; j < src.length; j++) { //遍历旧的Entry数组  
          Entry<K, V> e = src[j];             //取得旧Entry数组的每个元素  
          if (e != null) {  
              src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）  
              do {  
                  Entry<K, V> next = e.next;  
                  int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 
                  e.next = newTable[i]; //标记[1]  
                  newTable[i] = e;      //将元素放在数组上  
                  e = next;             //访问下一个Entry链上的元素  
              } while (e != null);  
          }  
      }  
  }  
  ```

  ```
  怎么避免扩容：
  	如果需要存入大量的数据，并且已知道大小expect_size，那么就要指定HashMap对象的初始容量 = expect_size / loadFactor + 1，其中loadFactor是扩容因子 = 0.75，可以有效避免扩容。
  ```

  

- HashMap、HashSet、HashTable线程安全吗，有哪些不同？

  ```
  首先HashMap是线程不安全的，其主要体现：（参考https://www.cnblogs.com/developer_chan/p/10450908.html）
  
  #1.在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。
  
  #2.在jdk1.8中，在多线程环境下，会发生数据覆盖的情况。
  ```

  ```
  HashSet基于HashMap实现，也是线程不安全的。
  ```

  ```
  HashTable元素操作的方法put和get都加了同步锁synchronized，是线程安全的。
  ```

  区别：

  | HashMap                                     | HashSet                                                      |
  | ------------------------------------------- | ------------------------------------------------------------ |
  | HashMap实现了Map接口                        | HashSet实现了Set接口                                         |
  | HashMap储存键值对                           | HashSet仅仅存储对象                                          |
  | 使用put()方法将元素放入map中                | 使用add()方法将元素放入set中                                 |
  | HashMap中使用键来计算hashcode值             | HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false |
  | HashMap比较快，因为是使用唯一的键来获取对象 | HashSet较HashMap来说比较慢                                   |

  | HashMap              | HashTable                    |
  | -------------------- | ---------------------------- |
  | 允许key和value为null | key和value都不允许为null     |
  | 重新计算hash值       | 使用Object默认的hashcode方法 |
  | 默认容量大小16       | 默认容量11                   |
  | 扩容方式 2倍         | 扩容方式 2倍+1               |

- Java内存模型了解多少，怎么保证可见性、原子性、有序性？

  可以通过以下对应的方式：

  | 可见性                        | 原子性                                        | 有序性                                       |
  | ----------------------------- | --------------------------------------------- | -------------------------------------------- |
  | volatile、final、synchronized | 包concurrent.atomic下的原子方法、synchronized | volatile（防止指令重排）、synchronized、lock |

- java中有哪些锁，区别是什么？

  ![](https://github.com/qxkmust/Alex.blog.github.io/blob/blog/Images/java%2012%E7%A7%8D%E9%94%81.png?raw=true)
  
- spring ioc中bean的生命周期？

  ```
  Spring容器的refresh()【创建刷新】;
  1、prepareRefresh()刷新前的预处理;
  	1）、initPropertySources()初始化一些属性设置;子类自定义个性化的属性设置方法；
  	2）、getEnvironment().validateRequiredProperties();检验属性的合法等
  	3）、earlyApplicationEvents= new LinkedHashSet<ApplicationEvent>();保存容器中的一些早期的事件；
  2、obtainFreshBeanFactory();获取BeanFactory；
  	1）、refreshBeanFactory();刷新【创建】BeanFactory；
  			创建了一个this.beanFactory = new DefaultListableBeanFactory();
  			设置id；
  	2）、getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象；
  	3）、将创建的BeanFactory【DefaultListableBeanFactory】返回；
  3、prepareBeanFactory(beanFactory);BeanFactory的预准备工作（BeanFactory进行一些设置）；
  	1）、设置BeanFactory的类加载器、支持表达式解析器...
  	2）、添加部分BeanPostProcessor【ApplicationContextAwareProcessor】
  	3）、设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx；
  	4）、注册可以解析的自动装配；我们能直接在任何组件中自动注入：
  			BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext
  	5）、添加BeanPostProcessor【ApplicationListenerDetector】
  	6）、添加编译时的AspectJ；
  	7）、给BeanFactory中注册一些能用的组件；
  		environment【ConfigurableEnvironment】、
  		systemProperties【Map<String, Object>】、
  		systemEnvironment【Map<String, Object>】
  4、postProcessBeanFactory(beanFactory);BeanFactory准备工作完成后进行的后置处理工作；
  	1）、子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置
  	
  ======================以上是BeanFactory的创建及预准备工作=======================
  5、invokeBeanFactoryPostProcessors(beanFactory);执行BeanFactoryPostProcessor的方法；
  	BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的；
  	两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor
  	1）、执行BeanFactoryPostProcessor的方法；
  		先执行BeanDefinitionRegistryPostProcessor
  		1）、获取所有的BeanDefinitionRegistryPostProcessor；
  		2）、看先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor、
  			postProcessor.postProcessBeanDefinitionRegistry(registry)
  		3）、在执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor；
  			postProcessor.postProcessBeanDefinitionRegistry(registry)
  		4）、最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors；
  			postProcessor.postProcessBeanDefinitionRegistry(registry)
  			
  		
  		再执行BeanFactoryPostProcessor的方法
  		1）、获取所有的BeanFactoryPostProcessor
  		2）、看先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor、
  			postProcessor.postProcessBeanFactory()
  		3）、在执行实现了Ordered顺序接口的BeanFactoryPostProcessor；
  			postProcessor.postProcessBeanFactory()
  		4）、最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor；
  			postProcessor.postProcessBeanFactory()
  6、registerBeanPostProcessors(beanFactory);注册BeanPostProcessor（Bean的后置处理器）【 intercept bean creation】
  		不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的
  		BeanPostProcessor、
  		DestructionAwareBeanPostProcessor、
  		InstantiationAwareBeanPostProcessor、
  		SmartInstantiationAwareBeanPostProcessor、
  		MergedBeanDefinitionPostProcessor【internalPostProcessors】、
  		
  		1）、获取所有的 BeanPostProcessor;后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级
  		2）、先注册PriorityOrdered优先级接口的BeanPostProcessor；
  			把每一个BeanPostProcessor；添加到BeanFactory中
  			beanFactory.addBeanPostProcessor(postProcessor);
  		3）、再注册Ordered接口的
  		4）、最后注册没有实现任何优先级接口的
  		5）、最终注册MergedBeanDefinitionPostProcessor；
  		6）、注册一个ApplicationListenerDetector；来在Bean创建完成后检查是否是ApplicationListener，如果是
  			applicationContext.addApplicationListener((ApplicationListener<?>) bean);
  7、initMessageSource();初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；
  		1）、获取BeanFactory
  		2）、看容器中是否有id为messageSource的，类型是MessageSource的组件
  			如果有赋值给messageSource，如果没有自己创建一个DelegatingMessageSource；
  				MessageSource：取出国际化配置文件中的某个key的值；能按照区域信息获取；
  		3）、把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource；
  			beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);	
  			MessageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale);
  8、initApplicationEventMulticaster();初始化事件派发器；
  		1）、获取BeanFactory
  		2）、从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster；
  		3）、如果上一步没有配置；创建一个SimpleApplicationEventMulticaster
  		4）、将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件直接自动注入
  9、onRefresh();留给子容器（子类）
  		1、子类重写这个方法，在容器刷新的时候可以自定义逻辑；
  10、registerListeners();给容器中将所有项目里面的ApplicationListener注册进来；
  		1、从容器中拿到所有的ApplicationListener
  		2、将每个监听器添加到事件派发器中；
  			getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
  		3、派发之前步骤产生的事件；
  11、finishBeanFactoryInitialization(beanFactory);初始化所有剩下的单实例bean；
  	1、beanFactory.preInstantiateSingletons();初始化后剩下的单实例bean
  		1）、获取容器中的所有Bean，依次进行初始化和创建对象
  		2）、获取Bean的定义信息；RootBeanDefinition
  		3）、Bean不是抽象的，是单实例的，是懒加载；
  			1）、判断是否是FactoryBean；是否是实现FactoryBean接口的Bean；
  			2）、不是工厂Bean。利用getBean(beanName);创建对象
  				0、getBean(beanName)； ioc.getBean();
  				1、doGetBean(name, null, null, false);
  				2、先获取缓存中保存的单实例Bean。如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）
  					从private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);获取的
  				3、缓存中获取不到，开始Bean的创建对象流程；
  				4、标记当前bean已经被创建
  				5、获取Bean的定义信息；
  				6、【获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来；】
  				7、启动单实例Bean的创建流程；
  					1）、createBean(beanName, mbd, args);
  					2）、Object bean = resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor先拦截返回代理对象；
  						【InstantiationAwareBeanPostProcessor】：提前执行；
  						先触发：postProcessBeforeInstantiation()；
  						如果有返回值：触发postProcessAfterInitialization()；
  					3）、如果前面的InstantiationAwareBeanPostProcessor没有返回代理对象；调用4）
  					4）、Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean
  						 1）、【创建Bean实例】；createBeanInstance(beanName, mbd, args);
  						 	利用工厂方法或者对象的构造器创建出Bean实例；
  						 2）、applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
  						 	调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);
  						 3）、【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper);
  						 	赋值之前：
  						 	1）、拿到InstantiationAwareBeanPostProcessor后置处理器；
  						 		postProcessAfterInstantiation()；
  						 	2）、拿到InstantiationAwareBeanPostProcessor后置处理器；
  						 		postProcessPropertyValues()；
  						 	=====赋值之前：===
  						 	3）、应用Bean属性的值；为属性利用setter方法等进行赋值；
  						 		applyPropertyValues(beanName, mbd, bw, pvs);
  						 4）、【Bean初始化】initializeBean(beanName, exposedObject, mbd);
  						 	1）、【执行Aware接口方法】invokeAwareMethods(beanName, bean);执行xxxAware接口的方法
  						 		BeanNameAware\BeanClassLoaderAware\BeanFactoryAware
  						 	2）、【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
  						 		BeanPostProcessor.postProcessBeforeInitialization（）;
  						 	3）、【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);
  						 		1）、是否是InitializingBean接口的实现；执行接口规定的初始化；
  						 		2）、是否自定义初始化方法；
  						 	4）、【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization
  						 		BeanPostProcessor.postProcessAfterInitialization()；
  						 5）、注册Bean的销毁方法；
  					5）、将创建的Bean添加到缓存中singletonObjects；
  				ioc容器就是这些Map；很多的Map里面保存了单实例Bean，环境信息。。。。；
  		所有Bean都利用getBean创建完成以后；
  			检查所有的Bean是否是SmartInitializingSingleton接口的；如果是；就执行afterSingletonsInstantiated()；
  12、finishRefresh();完成BeanFactory的初始化创建工作；IOC容器就创建完成；
  		1）、initLifecycleProcessor();初始化和生命周期有关的后置处理器；LifecycleProcessor
  			默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】；如果没有new DefaultLifecycleProcessor();
  			加入到容器；
  			
  			写一个LifecycleProcessor的实现类，可以在BeanFactory
  				void onRefresh();
  				void onClose();	
  		2）、	getLifecycleProcessor().onRefresh();
  			拿到前面定义的生命周期处理器（BeanFactory）；回调onRefresh()；
  		3）、publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件；
  		4）、liveBeansView.registerApplicationContext(this);
  	
  	======总结===========
  	1）、Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息；
  		1）、xml注册bean；<bean>
  		2）、注解注册Bean；@Service、@Component、@Bean、xxx
  	2）、Spring容器会合适的时机创建这些Bean
  		1）、用到这个bean的时候；利用getBean创建bean；创建好以后保存在容器中；
  		2）、统一创建剩下所有的bean的时候；finishBeanFactoryInitialization()；
  	3）、后置处理器；BeanPostProcessor
  		1）、每一个bean创建完成，都会使用各种后置处理器进行处理；来增强bean的功能；
  			AutowiredAnnotationBeanPostProcessor:处理自动注入
  			AnnotationAwareAspectJAutoProxyCreator:来做AOP功能；
  			xxx....
  			增强的功能注解：
  			AsyncAnnotationBeanPostProcessor
  			....
  	4）、事件驱动模型；
  		ApplicationListener；事件监听；
  		ApplicationEventMulticaster；事件派发：
  ```

- spring中的循环依赖问题？如何解决？

  #### 一、循环依赖的产生和解决的前提

  ```
  循环依赖的产生可能有很多种情况，例如：
  
  1) A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象
  2) A的构造方法中依赖了B的实例对象，同时B的某个field或者setter需要A的实例对象，以及反之
  3) A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象
  Spring对于循环依赖的解决不是无条件的，Spring解决循环依赖的前提是：是针对scope单例并且显式指明需要解决循环依赖的对象，而且要求该对象没有被代理过。同时Spring解决循环依赖也不是万能，以上三种情况只能解决两种，第一种在构造方法中相互依赖的情况Spring也无力回天。
  
  对于多例“prototype”作用域Bean，Spring容器无法完成依赖注入，因为“prototype”作用域的Bean，Spring容器不进行缓存，因此无法提前暴露一个创建中的Bean。
  ```

  #### 二、Spring循环依赖的理论依据

  ```
  spring对单例对象的初始化比较特殊，分为三步：
  
  step1： createBeanInstance ，也就是调用构造方法进行实例化， xml中指定的property并没有进行赋值 
  
  step2： populateBean， 填充属性值， 这步对xml中指定的property进行填充 
  
  step3： initializeBean ，调用xml中指定的init方法`，或者AfterPropertiesSet方法 
  ```

  循环依赖发生在前两步

  #### 三、spring使用三级缓存解决单实例bean的循环依赖

  ```
  对于单例对象来说，在Spring的整个容器的生命周期内，有且只存在一个对象，这个对象存在Cache中，Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至使用了“三级缓存”。
  ```

  ```
  	/** 一级缓存：存放所有注入到ioc中的bean实例 */
  	private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
  
  	/** 三级缓存：存放单例对象的工厂，用于从beanFactory中创建bean实例 */
  	private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);
  
  	/** 二级缓存：存放提前曝光的bean实例 */
  	private final Map<String, Object> earlySingletonObjects = new HashMap<>(16);
  
  	/** 用于存放正在创建中的bean实例（只实例化，未填充属性） */
  	private final Set<String> singletonsCurrentlyInCreation =
  		Collections.newSetFromMap(new ConcurrentHashMap<>(16));	
  		
  解决循环依赖的核心代码：
  
  protected Object getSingleton(String beanName, boolean allowEarlyReference) {
  //首先从一级缓存singletonObjects中获取
     Object singletonObject = this.singletonObjects.get(beanName);
     //如果一级缓存没有，且当前bean正在创建中（isSingletonCurrentlyInCreation为true）
     if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
        synchronized (this.singletonObjects) {
        //从二级缓存中找
           singletonObject = this.earlySingletonObjects.get(beanName);
           //如果二级缓存也没有，且允许从三级缓存singletonFactories中获取（allowEarlyReference为true）
           if (singletonObject == null && allowEarlyReference) {
           //如果三级缓存拿到了，将bean实例放到二级缓存，并从三级缓存中删除
              ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
              if (singletonFactory != null) {
                 singletonObject = singletonFactory.getObject();
                 this.earlySingletonObjects.put(beanName, singletonObject);
                 this.singletonFactories.remove(beanName);
              }
           }
        }
     }
     //如果三级缓存都拿不到，返回null
     return (singletonObject != NULL_OBJECT ? singletonObject : null);}
  ```

  ![](https://github.com/qxkmust/Alex.blog.github.io/blob/blog/Images/spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png?raw=true)

解读过程：

```
让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，长大成人，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象也蜕变完美了！一切都是这么神奇！！
```

